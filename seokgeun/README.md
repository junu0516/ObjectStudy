# Object 오브젝트
### 이 책을 공부하는 이유
- 객체지향 패러다임에 대한 전반적인 지식을 머릿속에 그릴 수 있게 하며, 객체지향에 대한 다양한 오해를 제거함으로써 개발자들이 동일한 규칙과 표준에 따라 프로그램을 작성할 수 있도록 하기 위함.
- 프로그래밍 패러다임 세계에선, 한 패러다임(여기선, 객체지향 패러다임)을 공부한다는 것은 과거 패러다임의 단점을 보완할 수도 있으며, 다른 개념의 패러다임을 더 잘 이해하기 위한 포석이 될 것임을 의미한다.

### Robert L. Glass - 소프트웨어 크리에이티비티 2.0 에서 논한 주제 "이론 vs 실무"
- 대부분의 사람들이 이론이 먼저 정립된 후 실무가 발전한다고 생각하지만, 그는 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다고 한다.
- 이 책을 공부하면서도, 객체지향 패러다임을 설명하기 위해 추상적인 개념이나 이론을 구체적으로 살펴본다기보단, 개발자인 우리가 가장 잘 이해할 수 있는 ‘코드’를 이용해 객체지향을 공부하게 될 예정이다.


#  Chapter 1. 객체, 설계
### 프로그래밍 패러다임(programming paradigm)
- 간단히 설명하자면, 개발자 공동체의 프로그래밍 스타일, 그리고 전체적인 프로그래밍 방식을 의미한다.
- 대표적인 프로그래밍 패러다임에는 절차적, 객체지향, 함수형 프로그래밍이 존재한다.
- 프로그래밍 패러다임은 공존할 수 있다. 그 예로 절차형 패러다임과 객체지향 패러다임을 접목시킨 C++ , 함수형 패러다임과 객체지향 패러다임을 접목시킨 Scala 가 있다.

### Robert C. Martin - 소프트웨어 모듈의 세 가지 목적
1. 실행 중 제대로 동작해야 한다.
2. 변경을 위해 존재 - 대부분의 모듈은 생명주기 동안 변경되기 때문에, 간단한 작업만으로도 변경 가능해야 한다.
3. 코드를 읽는 사람과 의사소통 (훈련 없이도 쉽게 읽고 이해할 수 있어야 함)

위 개념을 잘 이해하기 위하여 객체&설계 관련 예제를 제시한다.

## 예제 - 소극장 상황 가정 후 클래스 설계 및 상황 부여 완료 - 책 참고

@ 기존 enter 코드 동작 flow
1. 먼저 관람객 가방 안에 초대장이 있는지 확인한다.
2. 만약 들어있다면 이벤트에 당첨된 관람객이므로 판매원에게서 받은 티켓을 관람객 가방에 넣어준다.
3. 초대장이 없다면 티켓을 판매해야 하기 때문에, 이 경우에는 소극장은 관람객의 가방에서 티켓 금액만큼을 차감한 후 매표소에 금액을 증가시킨다.
4. 마지막으로 소극장은 관람객의 가방 안에 티켓을 넣어줌으로써 관람객의 입장 절차를 끝낸다.
   
@ 문제점 
- 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재가 되어버린다.
- 소극장이 우리 가방을 열어서 돈을 뺏고 티켓을 넣어주는… 우리 상식과 다르게 동작하기 때문에 코드를 읽는 사람과 제대로 의사소통하지 못한다.
- 이 코드를 이해하기 위해서는 여러 세부 내용들을 한꺼번에 기억해야 한다는 점이다.
- 이 코드는 하나의 클래스나 메소드에서 너무 많은 세부 내용을 다루기 때문에 코드 작성자나, 읽고 이해해야 하는 사람 모두에게 큰 부담을 준다.
- 변경에 취약하다. 여러 세부 상황 중 예를 들어 가방이 없는 상황이나 카드 결제 등.. 수정이나 컨셉이 바뀌면 너무 많은 코드를 바꿔야 한다. -> 의존성 증가

@ 문제 리뷰
- 객체 사이 의존성이 과한 경우 결합도가 높다고 말한다. 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다.
- 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다.

@ 해결하기 - 자율성을 높이자
각 객체가 자율성을 갖도록 하자.
- 1단계 : `Theater`에서 `TicketOffice`로의 의존성 제거
  - Theater 에서 수행하던 `enter`메소드 내용을 `TicketSeller` 클래스에 `sellTo` 라는 메소드를 생성하여 그곳에 넣어준다.
  - 캡슐화를 통해 `ticketOffice`에 대한 접근은 오직 `TicketSeller` 안에서만 존재하게 만든다.
  - 이제 Theater 의 `enter`메소드는 `TicketSeller.sellTo`를 호출하면 된다.


- 2단계 : `Audience` 캡슐화 개선 - `Bag`에 접근하는 모든 로직을 Audience 내부로 감추기
  - `sellTo`에서 `audience.getBack()` 으로 접근하는 코드를 `audience.buy` 로 변경
  - 변경된 코드에서, `Audience`는 자신의 가방 안에 초대장이 들어있는 지를 스스로 확인한다. 외부 제3자가 자신의 가방을 열어보도록 허용하지 않음.
  - `Bag`의 존재를 내부로 캡슐화 완료. 이제 `TicketSeller`는 `Audience`의 인터페이스에만 의존하게 된다.
  - `ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));`
  - 이제 `TicketSeller`와 `Audience`사이 결합도가 낮아졌다. 또한 내부 구현이 캡슐화됐으므로 `Audience`의 구현을 수정하더라도 `TicketSeller`에는 영향을 미치지 않음.
  - 2단계 작업을 통해 개선한 점
    - `Audience`, `TicketSeller`는 자신이 가지고 있는 소지품을 자신이 직접 관리하여, 상식에 맞기 때문에(예상과 일치) 코드를 읽는 사람과의 의사소통 관점에서, 확실히 개선됨
    - 변경 용이성 개선 - `Audience`나 `TicketSeller`의 내부 구현을 변경하더라도, `Theater`를 함께 변경할 필요가 없다.

### 핵심은 무엇인가?
- 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메세지를 통해서만(ex. sellTo,buy method) 상호작용하도록 만드는 것이 중요하다.
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 `응집도(cohesion)` 가 높다고 말한다.
- 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다.
- 외부의 간섭을 최대한 배제하고 메세지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계라고 할 수 있다.

### 절차지향과 객체지향
- 수정하기 전 코드는 절차를 구현했다고 볼 수 있다. <br>이 관점에서 `Theater`의 `enter` 메소드는 프로세스(Process)이며, `Audience`,`TicketSeller`,`Bag`,`TicketOffice`는 데이터(Data)이다. <br>이처럼 프로세스와 데이터를 별도 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 한다.
- 절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.<br>변경 후처럼, 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다.


### 책임의 이동(shift of responsibility) 
(여기서 책임은 객체의 기능을 가리킨다고 이해한다.)
- 하나의 기능을 완성하기 위한 책임이 `Theater`에 집중되어 있는 절차지향 설계에서 기능에 필요한 책임이 여러 객체에 걸쳐 분산돼있는 객체지향 설계로 바뀌었다고 이해하면 된다.
- 객체지향에 갓 입문한 우리 같은 경우, 프로세스와 데이터를 하나의 단위로 통합해 놓는 방식으로 코딩 첫걸음을 떼면 좋을 것이다. 물론 공부를 진행해나가면서 그 이상의 것들을 습득하게 될 것이다.

### 의인화(anthropomorphism)
`Bag`, `TicketOffice` 같은 경우, 실세계에서는 자율적인 존재가 아니다. <br>하지만, 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화라고 부른다. <br>좋은 객체지향 설계란, 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다. 비록 실세계에서는 생명이 없는 수동적인 존재라 하더라도.


---
### Bag Class - C#
```C#
public class Bag 
{
    private Long amount;
    private Invitation invitation;
    private Ticket ticket;
    public Ticket Ticket
    {
        get { return ticket; }
        set { ticket = value; }
    }

    public Bag(Long amount)
    {
        this.amount = amount;
    }

    public Bag(Invitation invitation, Long amount) : this(amount)
    {
        this.invitation = invitation;
    }
// Java와 달리 C#의 경우 클래스가 생성(인스턴스화)될 때 생성자는 한번만 호출되어야 한다는 룰이 있다. 그래서 생성자 정의에 this 키워드를 사용하여 제어를 넘길 수 있다.(다른 생성자 호출))
// 부모 클래스 (베이스 클래스) 의 생성자를 호출할 수도 있다. 이럴 땐 base 키워드(java는 super)를 사용하여 부모 생성자를 호출할 수 있다.

    public Long hold(Ticket ticket)
    {
        if(hasInvitation())
        {
            Ticket = ticket;
            return 0L;
        }
        else
        {
            Ticket = ticket;
            minusAmount(ticket.Fee);
            return ticket.Fee;
        }
    }
    private boolean hasInvitation() 
    {
        return invitation != null;
    }

    private void minusAmount(Long amount)
    {
        this.amount -= amount;
    }
}
```
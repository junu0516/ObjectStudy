<h1> 1장 정리 </h1>
<h2>패러다임의 시대</h2>

- 패러다임(paradigm) :

  - 과거 -> 표준적인 모델을 따르거나 모방하는 상황을 가리킴(제한적인 상황)
  - 현재 -> 한 시대의 사회 전체가 공유하는 이론이나 방법, 문제의식 등의 체계

  - 쿤의 사례
    - 기존 과학 : 단계적인 발건의 누적 과정
    - 새로운 발견 ( 과학 혁명, <b>패러다임 전환</b>)

<br/>
- 프로그래밍 패러다임
: 개발자 공동체가 <b>동일한 프로그래밍 스타일과 모델을 공유함</b>으로써 불필요한 부분에 대한 의견 충돌 방지

- 객체지향 패러다임을 주로 사용한다고 하더라도 다른 패러다임을 배우는 것이 도움이 될 것
- 언제라도 다른 패러다임을 적용할 수 있는 시야 필요

<br/>
<br/>

<h2>객체 설계</h2>
<br/>

- 모듈 : 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소
  - 목적
    1. 실행 중에 제대로 동작 (모듈 존재 이유)
    2. 변경을 위해 존재 (간단한 작업만으로도 변경 가능해야 함)
    3. 코드를 읽는 사람과 의사소통 (훈련 없이도 쉽게 읽고 이해할 수 있어야 함, 우리 예상에서 크게 벗어나지 않는 코드)
- 문제점
  - 행동의 주체가 잘못 되어 있음
    → 소극장이 능동적이고, 판매원과 관람객이 수동적
    → 직관적이지 못하고, 이해하지 어려움
  - 관람객의 상태로 인해 코드의 오류가 발생할 가능성이 높음
    → 객체 사이의 의존성이 얽혀 한 객체가 변경될 때 다른 객체가 변경될 가능성이 높음 (불 필요한 의존성 제거 필요, 결합도(coupling)가 높음)

<br/>

- 문제점 해결 방안

1. `Audience` 와 `TicketSeller` 가 `Bag` , `TicketOffice` 를 처리하는 **자율적인 존재**가 되도록 설계를 변경하는 것

   1. `Theater` 의 `enter` 메서드에서 `TicketOffice` 에 접근하는 모든 코드를 `TicketSeller` 내**부로 숨김**

   → 외부에서 `ticketOffice` 에 직접 접근할 수 없음 (`ticketSeller` 를 통해서만 접근) - **캡슐화**

<br/>

```jsx
public class Theater {
	private TicketSeller ticketSeller;

	public Theater(TicketSeller ticketSeller){
		this.ticketSeller = ticketSeller;
	}
// before
	public void enter(Audience audience) { // 이 메서드를 TicketSeller 내부로 옮김(sellTo)
		if(audience.getBag().hasInvitation()) { // 초대장이 있는지 분기 처리
			...
		}
	}
}

// after
	public void enter(Audience audience) {
	ticketSeller.sellTo(audience); // -- b
}

```

b. Theater 오직 TicketSeller의 인터페이스에만 의존 (내부 구현 영역에 대한 정보가 없음)
→ 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성할 수 있음

- 개선 내용
  - 본인의 소지품 (속성)에 대해 본인이 직접 관리
    → 예상과 일치, 의사소통 유리
  - 한 객체의 변경에 대해 따라서 변경되지 않음 (불필요한 의존성 제거)

⇒ 사용자는 내용을 주체의 내부로 숨김. **스스로 관리할 수 있도록 변경 (책임의 이동)**
<br/>

- 절차 지향과 객체 지향
  - 절차 지향 : 프로세스(메서드)와 데이터(속성)을 별도의 모듈에 위치시키는 방식
  → 우리의 직관에 위배
  → 데이터의 변경으로 인한 영향을 고립시키기가 어려움
  - 객체지향 : 데이터와 프로세스가 동일한 모듈 내부에 위치하도록
  → 캡슐화를 이용해 의존성을 관리하여 객체 사이의 결합도 낮춤
  → 변경에 유연

<h3> 객체지향 설계의 필요성</h3>

- “변경 용이한 코드를 설계하는 것이 좋은 코드” - 요구사항은 항상 변경되기 때문 - 코드를 변경할 때 버그가 추가될 가능성이 높기 때문
  <br/>

훌륭한 객체지향 설계 : 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계
